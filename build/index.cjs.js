"use strict";require("reflect-metadata");var e=require("react"),t=require("react/jsx-runtime");class s{constructor(){this.instances=new Map,this.services=new Map}registerService(e){this.services.set(e.token,e)}resolve(e){const t=this.services.get(e);return"transient"===(null==t?void 0:t.lifecycle)?this.create(e):(this.instances.has(e)||this.instances.set(e,this.create(e)),this.instances.get(e))}get(e){return this.resolve(e)}create(e){return new e(...(Reflect.getMetadata("design:paramtypes",e)||[]).map(e=>this.resolve(e)))}}class n{constructor(){this.handlers=new Map,this.middlewares=[]}use(e){this.middlewares.push(e)}on(e,t){const s=this.handlers.get(e)||[];s.push(t),this.handlers.set(e,s)}async dispatch(e){const t={intent:e,metadata:{}};let s=-1;const n=async r=>{var i,o;if(r<=s)throw new Error("next() called twice");s=r;const a=this.middlewares[r];a?await a(t,()=>n(r+1)):await Promise.all(null!==(o=null===(i=this.handlers.get(e.type))||void 0===i?void 0:i.map(t=>t(e)))&&void 0!==o?o:[])};await n(0)}onScoped(e,t,s){return this.on(`${e}/${t}`,s)}dispatchScoped(e,t,s){return this.dispatch({type:`${e}/${t}`,payload:s})}}class r{constructor(){this.effects=new Map,this.trackers=new Set}on(e,t){this.effects.has(e)||this.effects.set(e,new Set);const s=this.effects.get(e);return s.add(t),()=>{s.delete(t),0===s.size&&this.effects.delete(e)}}emit(e){const t=this.effects.get(e);t&&t.forEach(t=>{const s=performance.now();try{try{t()}catch(t){console.error("[Effect]",e,t)}}finally{const t=performance.now()-s;this.notifyTrackers({name:e,duration:t})}})}track(e){return this.trackers.add(e),()=>this.trackers.delete(e)}async run(e,t){const s=performance.now(),n=await t(),r=performance.now()-s;return this.trackers.forEach(t=>t({name:e,duration:r})),n}notifyTrackers(e){this.trackers.forEach(t=>{try{t(e)}catch(e){console.error("[EffectManager] tracker error",e)}})}has(e){return this.effects.has(e)}clear(){this.effects.clear(),this.trackers.clear()}}function i(e,t){if(!e.capabilities.includes(t))throw new Error(`[Plugin:${e.id}] Missing capability: "${t}"`)}class o{constructor(){this.container=new s,this.intent=new n,this.effect=new r,this.modules=new Map,this.stores=[],this.$on=this.intent.on.bind(this.intent),this.$emit=this.intent.dispatch.bind(this.intent),this.$onIntent=this.intent.onScoped.bind(this.intent),this.$emitIntent=this.intent.dispatchScoped.bind(this.intent)}registerStore(e){this.stores.push(e)}use(e){const t=(s=this,n=e.manifest,{intent:{tap(e){i(n,"intent"),s.intent.use(async(t,s)=>{e(t.intent),await s()})},on:(e,t)=>(i(n,"intent"),s.intent.on(e,t))},effect:{track:e=>(i(n,"effect"),s.effect.track(t=>{e({pluginId:n.id,name:t.name,duration:t.duration})}))},store:{observe(e){i(n,"store"),s.getStores().forEach(t=>t.observe(e))}},runtime:{log(...e){console.log(`[plugin:${n.name}]`,...e)},version:()=>"0.1.0"},service:{get:e=>(i(n,"service"),s.container.get(e))},meta:{id:n.id,name:n.name}});var s,n;e.setup(t)}useModule(e){this.modules.set(e.name,e)}async initModules(){this.modules.forEach(e=>{var t,s;null===(t=e.dependencies)||void 0===t||t.forEach(t=>{var s,n;null===(n=null===(s=this.modules.get(t))||void 0===s?void 0:s.onModuleLoaded)||void 0===n||n.call(s,e)}),e.setup(this),null===(s=e.onInit)||void 0===s||s.call(e,this)})}destroyModules(){this.modules.forEach(e=>{var t;return null===(t=e.onDestroy)||void 0===t?void 0:t.call(e)})}getModule(e){return this.modules.get(e)}getStores(){return this.stores}}const a={manifest:{id:"observability",name:"ObservabilityPlugin",capabilities:["intent"]},setup(e){e.intent.tap(e=>{console.log("[Intent]",e.type)})}},c=e.createContext(null);function u(){const t=e.useContext(c);if(!t)throw new Error("No Runtime");return t}let l=e=>()=>{};exports.AppRuntime=o,exports.EffectManager=r,exports.Injectable=function(e={}){return function(t){Reflect.defineMetadata("service:def",Object.assign({token:t,lifecycle:"singleton"},e),t),globalThis.__injectableRegistry||(globalThis.__injectableRegistry=new Set),globalThis.__injectableRegistry.add(t)}},exports.ObservabilityPlugin=a,exports.RuntimeProvider=({runtime:e,children:s})=>t.jsx(c.Provider,{value:e,children:s}),exports.Store=class{constructor(e,t){this.state=e,this.pluginLogId=t,this.listeners=new Set,this.computed=new Map,this.observers=new Set,this.id=`store-${Math.random().toString(36).slice(2,10)}`,this.id=t||this.id}get(){return this.state}set(e){this.state=Object.assign(Object.assign({},this.state),e),this.listeners.forEach(e=>e(this.state)),this.observers.forEach(e=>e({storeId:this.id,nextState:this.state}))}subscribe(e){return this.listeners.add(e),()=>this.listeners.delete(e)}computedValue(e,t){this.computed.set(e,t)}getComputed(e){var t;return null===(t=this.computed.get(e))||void 0===t?void 0:t(this.state)}observe(e){return this.observers.add(e),()=>this.observers.delete(e)}watch(e){return e(this.state),this.subscribe(e)}},exports.computedAsync=function(e,t,s){let n,r=!1;e.computedValue(t,()=>n);const i=async()=>{if(!r){r=!0;try{n=await s(e.get()),e.set({})}finally{r=!1}}},o=e.subscribe(i);return i(),()=>{o()}},exports.createApp=function(){return new o},exports.createModule=function(e){return e},exports.defineService=function(e){return e},exports.loadRemotePlugin=async function(e){const t=await import(e.url);return e.exportName?t[e.exportName]:t.default},exports.registerService=function(e,t){const s=Reflect.getMetadata("service:def",t);s&&e.container.registerService(s)},exports.useComputed=function(t,s=[]){const n=e.useMemo(()=>{let e=null;return t=>(e=l(),()=>{null==e||e()})},s);return e.useSyncExternalStore(n,t,t)},exports.useEffectIntent=function(t,s){const n=u();e.useEffect(()=>{const e=n.effect.on(t,s);return()=>{null==e||e()}},[n,t,s])},exports.useIntent=function(e){const t=u();return(s,n)=>{t.intent.dispatch({type:e?`${e}/${s}`:s,payload:n})}},exports.useModule=function(e){return u().container.resolve(e)},exports.useModuleInstance=function(e){const t=u().getModule(e);if(!t)throw new Error(`Module ${e} not found`);return t},exports.useRuntime=u,exports.useStore=function(t){return e.useSyncExternalStore(t.subscribe.bind(t),()=>t.get())};
