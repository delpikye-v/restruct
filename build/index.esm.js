import"reflect-metadata";import{useSyncExternalStore as t,createContext as e,useContext as s,useMemo as n,useEffect as i}from"react";import{jsx as r}from"react/jsx-runtime";class o{constructor(){this.instances=new Map,this.services=new Map}registerService(t){this.services.set(t.token,t)}resolve(t){const e=this.services.get(t);return"transient"===(null==e?void 0:e.lifecycle)?this.create(t):(this.instances.has(t)||this.instances.set(t,this.create(t)),this.instances.get(t))}get(t){return this.resolve(t)}create(t){return new t(...(Reflect.getMetadata("design:paramtypes",t)||[]).map(t=>this.resolve(t)))}}class a{constructor(){this.handlers=new Map,this.middlewares=[]}use(t){this.middlewares.push(t)}on(t,e){const s=this.handlers.get(t)||[];s.push(e),this.handlers.set(t,s)}async dispatch(t){const e={intent:t,metadata:{}};let s=-1;const n=async i=>{var r,o;if(i<=s)throw new Error("next() called twice");s=i;const a=this.middlewares[i];a?await a(e,()=>n(i+1)):await Promise.all(null!==(o=null===(r=this.handlers.get(t.type))||void 0===r?void 0:r.map(e=>e(t)))&&void 0!==o?o:[])};await n(0)}onScoped(t,e,s){return this.on(`${t}/${e}`,s)}dispatchScoped(t,e,s){return this.dispatch({type:`${t}/${e}`,payload:s})}}class c{constructor(){this.effects=new Map,this.trackers=new Set}on(t,e){this.effects.has(t)||this.effects.set(t,new Set);const s=this.effects.get(t);return s.add(e),()=>{s.delete(e),0===s.size&&this.effects.delete(t)}}emit(t){const e=this.effects.get(t);e&&e.forEach(e=>{const s=performance.now();try{try{e()}catch(e){console.error("[Effect]",t,e)}}finally{const e=performance.now()-s;this.notifyTrackers({name:t,duration:e})}})}track(t){return this.trackers.add(t),()=>this.trackers.delete(t)}async run(t,e){const s=performance.now(),n=await e(),i=performance.now()-s;return this.trackers.forEach(e=>e({name:t,duration:i})),n}notifyTrackers(t){this.trackers.forEach(e=>{try{e(t)}catch(t){console.error("[EffectManager] tracker error",t)}})}has(t){return this.effects.has(t)}clear(){this.effects.clear(),this.trackers.clear()}}function l(t,e){if(!t.capabilities.includes(e))throw new Error(`[Plugin:${t.id}] Missing capability: "${e}"`)}class h{constructor(){this.container=new o,this.intent=new a,this.effect=new c,this.modules=new Map,this.stores=[],this.$on=this.intent.on.bind(this.intent),this.$emit=this.intent.dispatch.bind(this.intent),this.$onIntent=this.intent.onScoped.bind(this.intent),this.$emitIntent=this.intent.dispatchScoped.bind(this.intent)}registerStore(t){this.stores.push(t)}use(t){const e=(s=this,n=t.manifest,{intent:{tap(t){l(n,"intent"),s.intent.use(async(e,s)=>{t(e.intent),await s()})},on:(t,e)=>(l(n,"intent"),s.intent.on(t,e))},effect:{track:t=>(l(n,"effect"),s.effect.track(e=>{t({pluginId:n.id,name:e.name,duration:e.duration})}))},store:{observe(t){l(n,"store"),s.getStores().forEach(e=>e.observe(t))}},runtime:{log(...t){console.log(`[plugin:${n.name}]`,...t)},version:()=>"0.1.0"},service:{get:t=>(l(n,"service"),s.container.get(t))},meta:{id:n.id,name:n.name}});var s,n;t.setup(e)}useModule(t){this.modules.set(t.name,t)}async initModules(){this.modules.forEach(t=>{var e,s;null===(e=t.dependencies)||void 0===e||e.forEach(e=>{var s,n;null===(n=null===(s=this.modules.get(e))||void 0===s?void 0:s.onModuleLoaded)||void 0===n||n.call(s,t)}),t.setup(this),null===(s=t.onInit)||void 0===s||s.call(t,this)})}destroyModules(){this.modules.forEach(t=>{var e;return null===(e=t.onDestroy)||void 0===e?void 0:e.call(t)})}getModule(t){return this.modules.get(t)}getStores(){return this.stores}}function u(){return new h}function d(t){return t}function f(t,e){const s=Reflect.getMetadata("service:def",e);s&&t.container.registerService(s)}function p(t={}){return function(e){Reflect.defineMetadata("service:def",Object.assign({token:e,lifecycle:"singleton"},t),e),globalThis.__injectableRegistry||(globalThis.__injectableRegistry=new Set),globalThis.__injectableRegistry.add(e)}}function m(t){return t}class g{constructor(t,e){this.state=t,this.pluginLogId=e,this.listeners=new Set,this.computed=new Map,this.observers=new Set,this.id=`store-${Math.random().toString(36).slice(2,10)}`,this.id=e||this.id}get(){return this.state}set(t){this.state=Object.assign(Object.assign({},this.state),t),this.listeners.forEach(t=>t(this.state)),this.observers.forEach(t=>t({storeId:this.id,nextState:this.state}))}subscribe(t){return this.listeners.add(t),()=>this.listeners.delete(t)}computedValue(t,e){this.computed.set(t,e)}getComputed(t){var e;return null===(e=this.computed.get(t))||void 0===e?void 0:e(this.state)}observe(t){return this.observers.add(t),()=>this.observers.delete(t)}watch(t){return t(this.state),this.subscribe(t)}}function v(e){return t(e.subscribe.bind(e),()=>e.get())}function w(t,e,s){let n,i=!1;t.computedValue(e,()=>n);const r=async()=>{if(!i){i=!0;try{n=await s(t.get()),t.set({})}finally{i=!1}}},o=t.subscribe(r);return r(),()=>{o()}}async function b(t){const e=await import(t.url);return t.exportName?e[t.exportName]:e.default}const y={manifest:{id:"observability",name:"ObservabilityPlugin",capabilities:["intent"]},setup(t){t.intent.tap(t=>{console.log("[Intent]",t.type)})}},M=e(null),S=({runtime:t,children:e})=>r(M.Provider,{value:t,children:e});function E(){const t=s(M);if(!t)throw new Error("No Runtime");return t}function $(t){return E().container.resolve(t)}function k(t){const e=E();return(s,n)=>{e.intent.dispatch({type:t?`${t}/${s}`:s,payload:n})}}function j(t){const e=E().getModule(t);if(!e)throw new Error(`Module ${t} not found`);return e}function I(e,s=[]){const i=n(()=>{let t=null;return e=>(t=R(),()=>{null==t||t()})},s);return t(i,e,e)}let R=t=>()=>{};function x(t,e){const s=E();i(()=>{const n=s.effect.on(t,e);return()=>{null==n||n()}},[s,t,e])}export{h as AppRuntime,c as EffectManager,p as Injectable,y as ObservabilityPlugin,S as RuntimeProvider,g as Store,w as computedAsync,u as createApp,m as createModule,d as defineService,b as loadRemotePlugin,f as registerService,I as useComputed,x as useEffectIntent,k as useIntent,$ as useModule,j as useModuleInstance,E as useRuntime,v as useStore};
